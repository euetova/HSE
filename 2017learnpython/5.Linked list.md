# Связные списки (Linked list)

Структура данных для представления упорядоченного набора узлов. 

Односвязный список - связный список, в котором каждый узел содержит указатель на следующий узел в цепочке.

Двусвязный список - связный список, в котором каждый узел содержит два указателя: на следующий и предыдущий узел.

Связные списки чем-то похожи на массивы (упорядоченный набор элементов).

<table>
<tr>
<td width="20%"></td>
<td width="32%">Массив</td>
<td width="48%">Связный список</td>
</tr>
<tr>
<td>добавление элемента</td>
<td>если в конец - O(1)<br>иначе - O(n)</td>
<td>O(1) - поменять у предыдущего элемента номер следующего, у следующего - номер предыдущего</td>
</tr>
<tr>
<td>удаление элемента</td>
<td>если в конце - O(1)<br>иначе - O(n)</td>
<td>O(1) - поменять у предыдущего элемента номер следующего, у следующего - номер предыдущего</td>
</tr>
<tr>
<td>поиск</td>
<td>по индексу - O(1)<br>по значению - O(n)</td>
<td>O(n) - только перебором</td>
</tr>
</table>


```
class Node:
    def __init__(self, data, next=None):
        self.data = data
        self.next = next


class LinkedList:
    def __init__(self, head=None):
        self.head = head

    def empty(self):
        if self.head:
            return False
        return True

    def printList(self):
        node = self.head
        while node:
            print(node.data, end="->")
            node = node.next
        print()

    def push(self, data):
        node = Node(data, next=self.head)
        self.head = node

    def append(self, data):
        new_node = Node(data)
        if not self.head:
            self.head = new_node
        else:
            node = self.head
            while node.next:
                node = node.next
            node.next = new_node


n3 = Node(3)
n2 = Node(2, next=n3)
n1 = Node(1, next=n2)


l = LinkedList(head=n1)
for i in [1,2,3,4,5,4,5,6,6,6,6,1,1,54,3]:
    l.append(i)
l.printList()
```

# Метод бегунка
Связный список перебирается с помощью двух указателей одновременно, один впереди другого. Первый указатель может опережать второй указатель на фиксированное кол-во узлов, или например, может каждый раз смещаться на возрастающее кол-во узлов.
Метод бегунка (или метод указателей) используется во многих задачах про связные списки.

1. Даны два односвязных списка. Найти элемент, где они пересекаются (за линейное время, константную память)
2. Превратить список четной длины вида a1-a2-a3... -b1-b2-b3... в список вида a1-b1-a2-b2-a3-b3-...-...

#　Задания на семинар
Добавить в класс `LinkedList` следующие методы:

1. `size` - вернуть длину списка
7. `delete(value)` - удалить значение `value` из списка
8. `insert(index, value)` - вставить значение `value` в список в позиции `index`
9. `deleteAtPosition(index)` - удалить узел из списка в позиции `index`
2. `value_at(index)`- вернуть значение узла в позиции `index`
3. `pop_front` - удалить узел в начале связного списка и вернуть его значение
4. `pop_back` - удалить узел в конце связного списка и вернуть его значение
5. `front` - вернуть значение первого узла списка
6. `back` - вернуть значение последнего узла списка

# Домашнее задание
Нужно сдать код с классом `LinkedList`, в котором есть методы `push`, `append`, `insert`, `delete`, `size`.
Кроме того, нужно добавить в класс `LinkedList` один из следующих методов на ваш выбор:

1. `reverse` - перевернуть связный список (теперь начало в конце, а конец в начале, считаем что у нас список односвязный, массивы использовать нельзя, можно пользоваться классами `Node`  и `LinkedList`)
2. `value_n_from_end(n)` - возвращает n-ный с конца узел связного списка (считаем что у нас список односвязный, массивы использовать нельзя, можно пользоваться классами `Node`  и `LinkedList`)
